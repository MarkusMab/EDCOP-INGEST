apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "ingest.fullname" . }}-logstash-pipelines
data:   
{{- if .Values.logstashConfig.features.syslog.enabled }}
  syslog.conf: |
    input {
      tcp {
        port => 5144
        type => syslog
      }
      udp {
        port => 5144
        type => syslog
      }
    }
    
    filter {
      if [type] == "syslog" {
        {{- if .Values.logstashConfig.features.syslog.filters.cisco_asa }}
        # Cisco specific filters
        if "%ASA-" in [message] {
          mutate {
            add_tag => [ "Firewall", "ASA" ]
          }
          grok {
            match => ["message", "%{CISCO_TAGGED_SYSLOG} %{GREEDYDATA:cisco_message}"]   
          }
          if !("_grokparsefailure" in [tags]) {
            mutate {
              rename => ["cisco_message", "message"]
              remove_field => ["timestamp"]
            }
          }
          grok {
            match => [
              "message", "%{CISCOFW104001}",
              "message", "%{CISCOFW104002}",
              "message", "%{CISCOFW104003}",
              "message", "%{CISCOFW104004}",
              "message", "%{CISCOFW105003}",
              "message", "%{CISCOFW105004}",
              "message", "%{CISCOFW105005",
              "message", "%{CISCOFW105008",
              "message", "%{CISCOFW105009",
              "message", "%{CISCOFW106001}",
              "message", "%{CISCOFW106006_106007_106010}",
              "message", "%{CISCOFW106014}",
              "message", "%{CISCOFW106015}",
              "message", "%{CISCOFW106021}",
              "message", "%{CISCOFW106023}",
              "message", "%{CISCOFW106100_2_3}",
              "message", "%{CISCOFW106100}",
              "message", "%{CISCOFW304001}",
              "message", "%{CISCOFW110002}",
              "message", "%{CISCOFW302010}",
              "message", "%{CISCOFW302013_302014_302015_302016}",
              "message", "%{CISCOFW302020_302021}",
              "message", "%{CISCOFW305011}",
              "message", "%{CISCOFW313001_313004_313008}",
              "message", "%{CISCOFW313005}",
              "message", "%{CISCOFW321001}",
              "message", "%{CISCOFW402117}",
              "message", "%{CISCOFW402119}",
              "message", "%{CISCOFW419001}",
              "message", "%{CISCOFW419002}",
              "message", "%{CISCOFW500004}",
              "message", "%{CISCOFW602303_602304}",
              "message", "%{CISCOFW710001_710002_710003_710005_710006}",
              "message", "%{CISCOFW713172}",
              "message", "%{CISCOFW733100}"
            ]
          }    
          geoip {
            source => "src_ip"
            target => "geoip"
            add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
            add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
          }   
          mutate {
            convert => [ "[geoip][coordinates]", "float" ]
          }       
          {{- end }}    
        }
        
        # General syslog filtering
        syslog_pri { }      # Severity level
        date {
          match => [ "syslog_timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "MMM dd yyyy HH:mm:ss", "MMM  d yyyy HH:mm:ss" ]
        }          
      }
    }
    
    # enables stdout for debugging
    output {
      if [type] == "syslog" {
       stdout { codec => rubydebug }
      }
    }
    
    output {
      if [type] == "syslog" {
        elasticsearch {
          hosts => "data-service:9200"
          manage_template => false
          index => "syslog-%{+YYYY.MM.dd}"
          document_type => "%{[@metadata][type]}"
          codec => json
          #user => logstash_internal
          #password => changeme
        }
      }
    }
{{- end }}
{{- if .Values.logstashConfig.features.packetbeat.enabled }}
  packetbeat.conf: |
    input {
      redis {
        host => "ingest-service"
        key => "packetbeat"
        data_type => "list"
        tags => ["packetbeat"]
        codec => json
        batch_count => {{ .Values.logstashConfig.features.packetbeat.pipeline.batchCount }}
        threads => {{ .Values.logstashConfig.features.packetbeat.pipeline.threads }}
      }
    }
    output {
      if "packetbeat" in [tags] {
        elasticsearch {
          hosts => "data-service:9200"
          manage_template => false
          index => "packetbeat-%{+YYYY.MM.dd}"
          document_type => "event"
          codec => json
          #user => logstash_internal
          #password => changeme
        }
      }
    }
{{- end }}
{{- if .Values.logstashConfig.features.winlogbeat.enabled }}
  winlogbeat.conf: |
    input {
      redis {
        host => "ingest-service"
        key => "winlogbeat"
        data_type => "list"
        tags => ["winlogbeat"]
        codec => json
        batch_count => {{ .Values.logstashConfig.features.winlogbeat.pipeline.batchCount }}
        threads => {{ .Values.logstashConfig.features.winlogbeat.pipeline.threads }}
      }
    }

    output {
      if "winlogbeat" in [tags] {
        elasticsearch {
          hosts => "data-service:9200"
          manage_template => false
          index => "winlogbeat-%{+YYYY.MM.dd}"
          document_type => "event"
          codec => json
          #user => logstash_internal
          #password => changeme
        }
      }
    }
{{- end }}
{{- if .Values.logstashConfig.features.bro.enabled }}
  bro.conf: |
    input {
      redis {
        host => "ingest-service"
        key => "bro"
        data_type => "list"
        tags => ["bro"]
        codec => json
        batch_count => {{  .Values.logstashConfig.features.bro.pipeline.batchCount }}
        threads => {{  .Values.logstashConfig.features.bro.pipeline.threads }}
      }
    }
    filter {
      if "bro" in [tags] {
        json {
          source => "message"
        }
        geoip {
          source => "id.resp_h"
          target => "resp_geoip"
          add_field => [ "resp_location", "%{[resp_geoip][longitude]}" ]
          add_field => [ "resp_location", "%{[resp_geoip][latitude]}"  ]
        }
        mutate {
          convert => [ "resp_location", "float" ]
          replace => { "type" => "bro" }
          rename => { "id" => "bro_id" }
          #need to rename the following because Elastic assumes they are objects and fails
          rename => { "id.resp_p" => "bro_id_resp_p" }
          rename => { "id.resp_h" => "bro_id_resp_h" }
          rename => { "id.orig_p" => "bro_id_orig_p" }
          rename => { "id.orig_h" => "bro_id_orig_h" }
        }
      }
    }
    
    output {
      if "bro" in [tags] {
        elasticsearch {
          hosts => "data-service:9200"
          manage_template => false
          index => "bro-%{+YYYY.MM.dd}"
          document_type => "event"
          codec => json
          #user => logstash_internal
          #password => changeme
        }
      }
    }
{{- end }}
{{- if .Values.logstashConfig.features.suricata.enabled }}
  suricata.conf: |
    input {
      redis {
        host => "ingest-service"
        key => "suricata"
        data_type => "list"
        tags => ["suricata"]
        codec => json
        batch_count => {{  .Values.logstashConfig.features.suricata.pipeline.batchCount }}
        threads => {{  .Values.logstashConfig.features.suricata.pipeline.threads }}
      }
    }
    
    output {
      if "suricata" in [tags] {
        elasticsearch {
          hosts => "data-service:9200"
          manage_template => false
          index => "suricata-%{+YYYY.MM.dd}"
          document_type => "event"
          codec => json
          #user => logstash_internal
          #password => changeme
        }
      }
    }
{{- end }}